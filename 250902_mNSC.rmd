---
title: "Bulk RNAseq Analysis"
subtitle: "A Modular and Reproducible Pipeline"
author: "Ryan Miller"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
    html_document:
    toc: yes
    toc_float: yes
    toc_depth: 5
    code_folding: show
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
```

# Project 250902_mNSC
This document is the central hub for a modular DESeq2 RNA-seq analysis pipeline.

---

# 1. Setup

## 1.1 Child Scripts
```{r child-script-setup, file='scripts/00_setup.R', echo=TRUE}
```
```{r child-script-genes, file='scripts/01_genes_mouse.R', echo=TRUE}
```
```{r child-script-qc, file='scripts/02_QC.R', echo=TRUE}
```
```{r child-script-deseq, file='scripts/03_DESeq2.R', echo=TRUE}
```
```{r child-script-genesets, file='scripts/04_genesets.R', echo=TRUE}
```
```{r child-script-plotting-utils, file='scripts/05_plotting_utils.R', echo=TRUE}
```

## 1.2 Project Setup
```{r project-setup-and-caching}
cfg <- list(
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # GENERAL PROJECT SETTINGS
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  date = format(Sys.Date(), "%y%m%d"),
  project_name = "250902_mNSC",
  use_cache = FALSE, # Set to FALSE to re-run all analyses from scratch
  run_styler = FALSE, # Set to TRUE to format all R and Rmd files
  nc = parallel::detectCores() - 2, # Number of cores for parallel processing

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # DIRECTORY AND FILE PATHS
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  dir_input = here::here("input"),
  dir_output = here::here("output"),
  dir_sf = here::here("sf"), # Salmon quantification files
  dir_genesets = here::here("input", "genesets"),
  dir_graphs_png = here::here("graphs", "png"),
  dir_graphs_pdf = here::here("graphs", "pdf"),
  dir_data_csv = here::here("output", "csv"), # <---- ADDED
  file_samples = here::here("input", "samples.csv"),
  file_gtf = here::here("input", "gencode.vM37.primary_assembly.annotation.gtf.gz"),

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # DESEQ2 ANALYSIS SETTINGS
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  qval_threshold = 0.05, # Adjusted p-value threshold for significance
  lfc_threshold = 1.0, # Log2 fold change threshold for significance
  filter_min_count = 10, # Minimum read count for a gene to be kept
  batch_vars = c("SeqBatch"), # Variables to include as batch effects
  main_vars = c("Driver", "Model", "Host"), # Main experimental variables
  deg_design_vars = c("Host", "Model", "Driver"), # Variables for the design formula
  interaction_vars = c("Model", "Driver"), # Variables to test for interaction effects
  filter_by_factor = "Driver", # Factor to determine smallest group size for filtering
  interaction_simple_effect_direction = "var1", # "var1","var2","none","both"

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # PLOTTING SETTINGS
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  qc_plot_settings = list(project_genes = c("Egfr", "Pdgfra", "Pten", "Cdkn2a")),
  ryb = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 9, name = "RdYlBu")))(100),

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # ANALYSIS DEFINITIONS
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  analysis_definitions = list(
    # Define subsets of the data to analyze independently
    sample_subsets = list(
      Full_Dataset = list(),
      NS1_Model = list(Model = "NS1"),
      BL6_Host = list(Host = "BL6"),
      NSG_Host = list(Host = "NSG")
    ),
    # Define gene filters to apply
    gene_filters = list(
      all_genes = list(filter_gene_types = NULL),
      protein_coding = list(filter_gene_types = "protein_coding")
    ),
    # Define model types to run
    model_types = c("additive", "interaction")
  )
)

# If run_styler is TRUE, format all R and Rmd files in the project.
if (cfg$run_styler) {
  styler::style_file(c("250902_mNSC.rmd", list.files("scripts", pattern = "[.][rR]$", full.names = TRUE)))
}

# Check if the analysis should be run or if cached results should be loaded.
run_analysis_flag <- TRUE
results_file_path <- here::here(cfg$dir_input, paste0(cfg$project_name, "_results.RData"))
if (cfg$use_cache && file.exists(results_file_path)) {
  message("Loading results from cache...")
  load(results_file_path, envir = .GlobalEnv)
  run_analysis_flag <- FALSE
}

# Load sample metadata, remove unnecessary columns, and validate inputs.
samples <- read.csv(cfg$file_samples, row.names = 1, header = TRUE)
# Remove columns only needed for nf-core preprocessing
samples <- samples %>% dplyr::select(-c(fastq_1, fastq_2, strandedness))
validate_config_and_inputs(cfg, samples)

# Load all gene sets from the specified directory.
gene_sets <- load_gene_sets(cfg$dir_genesets)
```

---

# 2. Analysis

This section performs the core DESeq2 analysis. The analysis is structured as a series of nested loops that iterate through different sample subsets, gene filters, and statistical models, as defined in the `cfg$analysis_definitions` list.

```{r computational-analysis, echo=TRUE, eval=run_analysis_flag}
# Set a seed for reproducibility of stochastic processes.
set.seed(42)

# This function finds all directory paths in the config list and creates them.
create_project_dirs <- function(config) {
  dir_paths <- c()
  for (name in names(config)) {
    if (startsWith(name, "dir_")) {
      dir_paths <- c(dir_paths, config[[name]])
    }
  }
  # Base CSV dir
  dir_paths <- c(dir_paths, config$dir_data_csv)

  # Add per gene-filter CSV subdirs
  csv_subdirs <- file.path(config$dir_data_csv, names(config$analysis_definitions$gene_filters))
  all_dirs <- unique(c(dir_paths, csv_subdirs))
  lapply(all_dirs, dir.create, recursive = TRUE, showWarnings = FALSE)
}

create_project_dirs(cfg)

# Register a parallel backend to speed up the analysis, using the number of cores specified in the config.
if (cfg$nc > 1) {
  BiocParallel::register(BiocParallel::MulticoreParam(workers = cfg$nc))
}

# Convert character and integer columns in the sample metadata to factors, which is required for DESeq2.
samples[, sapply(samples, is.character)] <- lapply(samples[, sapply(samples, is.character)], as.factor)
vars_to_factor <- unique(c(cfg$batch_vars, cfg$main_vars))
for (var in vars_to_factor) {
  if (is.integer(samples[[var]])) {
    samples[[var]] <- as.factor(samples[[var]])
  }
}

# Create a named vector of paths to the Salmon quantification files.
files_sf <- file.path(cfg$dir_sf, paste0(rownames(samples), ".sf"))
names(files_sf) <- rownames(samples)

# Initialize lists to store the results of each analysis.
all_dds_objects <- list()
all_results_lists <- list()

# Main analysis loop iterates through all combinations of sample subsets, gene filters, and model types.
for (s_name in names(cfg$analysis_definitions$sample_subsets)) {
  for (filt_name in names(cfg$analysis_definitions$gene_filters)) {
    filt_params <- cfg$analysis_definitions$gene_filters[[filt_name]]

    # Create transcript-to-gene and gene name maps.
    gtf_maps <- create_tx2gene_maps(
      cfg$file_gtf, cfg$dir_input, filt_params$filter_gene_types,
      use_cache = cfg$use_cache
    )

    for (m_type in cfg$analysis_definitions$model_types) {
      analysis_name <- paste(s_name, filt_name, m_type, sep = "_")
      message(paste("\n--- STARTING ANALYSIS FOR:", analysis_name, "---"))

      # Subset the samples based on the criteria defined in the config.
      current_samples <- samples
      subset_criteria <- cfg$analysis_definitions$sample_subsets[[s_name]]
      if (length(subset_criteria) > 0) {
        for (col in names(subset_criteria)) {
          values_to_keep <- subset_criteria[[col]]
          current_samples <- current_samples[current_samples[[col]] %in% values_to_keep, ]
        }
        current_samples <- droplevels(current_samples)
      }

      if (nrow(current_samples) == 0) {
        message(paste("...SKIPPING analysis for", analysis_name, "because the data subset was empty."))
        next
      }

      current_files_sf <- files_sf[rownames(current_samples)]

      # Determine relevant variables present in current subset
      relevant_vars <- intersect(colnames(current_samples), unique(c(cfg$batch_vars, cfg$main_vars)))
      batch_terms <- intersect(cfg$batch_vars, relevant_vars)

      # (Re)build design string (ensure relevant_vars defined before use)
      # Remove variables with only one unique value from the design
      get_nonconstant_vars <- function(df, vars) {
        vars[sapply(vars, function(v) length(unique(df[[v]])) > 1)]
      }
      if (m_type == "additive") {
        design_terms <- intersect(cfg$deg_design_vars, relevant_vars)
        design_terms <- get_nonconstant_vars(current_samples, design_terms)
        batch_terms <- get_nonconstant_vars(current_samples, batch_terms)
        all_terms <- c(batch_terms, design_terms)
        if (length(all_terms) == 0) {
          message(paste("...SKIPPING analysis for", analysis_name, "because all design variables are constant."))
          next
        }
        design_str <- paste("~", paste(all_terms, collapse = " + "))
      } else {
        main_terms <- intersect(cfg$main_vars, relevant_vars)
        main_terms <- get_nonconstant_vars(current_samples, main_terms)
        batch_terms <- get_nonconstant_vars(current_samples, batch_terms)
        if (all(cfg$interaction_vars %in% main_terms)) {
          other_main_terms <- setdiff(main_terms, cfg$interaction_vars)
          interaction_term <- paste(cfg$interaction_vars, collapse = " * ")
          all_terms <- c(batch_terms, other_main_terms, interaction_term)
          if (length(all_terms) == 0) {
            message(paste("...SKIPPING analysis for", analysis_name, "because all design variables are constant."))
            next
          }
          design_str <- paste("~", paste(all_terms, collapse = " + "))
        } else {
          message(
            "...Skipping interaction model for ", analysis_name,
            " (missing required interaction vars)."
          )
          next
        }
      }

      # Run DESeq core with updated design
      dds_processed <- run_deseq_core(
        current_samples, current_files_sf, as.formula(design_str),
        gtf_maps$tx2gene_pcg, cfg$filter_by_factor, cfg$filter_min_count,
        parallel = (cfg$nc > 1)
      )
      all_dds_objects[[analysis_name]] <- dds_processed

      # Build standard pairwise comparisons
      factors_to_compare <- intersect(cfg$main_vars, relevant_vars)
      comparisons <- build_all_comparisons(dds_processed, factors_to_compare)

      # If interaction model, append interaction-derived contrasts
      if (m_type == "interaction") {
        interaction_contrasts <- generate_interaction_contrasts(
          dds_processed,
          cfg$interaction_vars,
          simple_effect_direction = cfg$interaction_simple_effect_direction
        )
        if (length(interaction_contrasts)) {
          comparisons <- c(comparisons, interaction_contrasts)
          message("...Added ", length(interaction_contrasts), " interaction contrasts.")
        } else {
          message("...No interaction contrasts generated (check resultsNames).")
        }
      }

      # Extract & save
      all_results_lists[[analysis_name]] <- extract_comparisons(
        dds_processed = dds_processed,
        comparisons_list = comparisons,
        analysis_name = analysis_name,
        gene_map = gtf_maps$gene_name_map,
        cfg = cfg,
        gene_sets = gene_sets,
        filt_name = filt_name
      )
    }
  }
}

# Save all results to an RData file for easy reloading.
save(
  cfg, samples, gtf_maps, all_dds_objects, all_results_lists, gene_sets,
  file = here::here(cfg$dir_input, paste0(cfg$project_name, "_results.RData"))
)
```

---

# 3. Reports and Visualizations

This section generates the final report, including tables of sample metadata, QC plots, and detailed results for each differential expression comparison.

## 3.1 Sample Metadata

The following table displays the sample metadata used in this analysis.

```{r sample-metadata-table}
reactable::reactable(samples, searchable = TRUE, filterable = TRUE, bordered = TRUE, highlight = TRUE)
```

## 3.2 Quality Control
```{r report-helpers, include=FALSE}
# Reusable helpers for report generation

if (!exists("sanitize_analysis_name")) {
  sanitize_analysis_name <- function(x) gsub("[^A-Za-z0-9_.-]", "_", x)
}

emit_image <- function(path) {
  if (file.exists(path)) cat(paste0("![](", path, ")\n"))
}

emit_section_header <- function(txt, level = 3) {
  cat(paste0("\n", paste(rep("#", level), collapse = ""), " ", txt, "\n"))
}

list_analysis_objects <- function(obj_list) {
  stats::setNames(as.list(names(obj_list)), names(obj_list))
}

# New helpers
emit_labeled_image <- function(label, path) {
  cat(paste0("\n##### ", label, "\n"))
  if (file.exists(path)) {
    cat(paste0("![](", path, ")\n"))
  } else {
    cat("*Missing plot:* ", basename(path), "\n")
  }
}

emit_gene_set_heatmap <- function(comp_name, gs_name, png_dir, date) {
  path <- file.path(png_dir, paste0(date, "_", comp_name, "_", gs_name, "_DEG_heatmap.png"))
  cat(paste0("\n##### ", gs_name, " Gene Set Heatmap\n"))
  if (file.exists(path)) {
    cat(paste0("![](", path, ")\n"))
  } else {
    cat("*No heatmap generated for this gene set.*\n")
  }
}

emit_gene_set_boxplots <- function(comp_name, gs_name, png_dir, date) {
  cat(paste0("\n##### ", gs_name, " Gene Set Boxplots\n"))
  prefix <- paste0(date, "_", comp_name, "_", gs_name, "_Boxplot_")
  esc_prefix <- gsub("([.^$|()*+?{\\[\\]\\\\])", "\\\\\\1", prefix)
  files <- list.files(png_dir, pattern = paste0("^", esc_prefix, ".+\\.png$"), full.names = TRUE)
  if (length(files) == 0) {
    cat("*No boxplots generated for this gene set.*\n")
  } else {
    for (f in files) cat(paste0("![](", f, ")\n"))
  }
}

emit_standard_comp_plots <- function(comp_name, png_dir, date) {
  emit_labeled_image("Volcano Plot", file.path(png_dir, paste0(date, "_", comp_name, "_volcano.png")))
  emit_labeled_image("Top 50 DEG Heatmap", file.path(png_dir, paste0(date, "_", comp_name, "_DEG_heatmap_top50.png")))
  emit_labeled_image("Top 250 DEG Heatmap", file.path(png_dir, paste0(date, "_", comp_name, "_DEG_heatmap_top250.png")))
}

# NEW: helper to emit significant gene table
emit_sig_gene_table <- function(sig_df, cfg) {
  if (nrow(sig_df) == 0) {
    cat("*No significant genes for this comparison.*\n")
    return(invisible(NULL))
  }
  tbl <- sig_df %>%
    dplyr::select(
      gene_name,
      human_ortholog,
      baseMean,
      log2FoldChange,
      padj
    ) %>%
    dplyr::arrange(padj)

  print(
    reactable::reactable(
      tbl,
      defaultPageSize = 5,
      searchable = TRUE,
      bordered = TRUE,
      highlight = TRUE,
      columns = list(
        gene_name = reactable::colDef(name = "Gene"),
        human_ortholog = reactable::colDef(name = "Human Ortholog"),
        baseMean = reactable::colDef(format = reactable::colFormat(digits = 1)),
        log2FoldChange = reactable::colDef(format = reactable::colFormat(digits = 2)),
        padj = reactable::colDef(format = reactable::colFormat(digits = 3))
      )
    )
  )
}
```

```{r dynamic-qc-plots, results='asis'}
emit_section_header("PCA Plots", level = 3)
for (analysis_name in names(all_dds_objects)) {
  safe_name <- sanitize_analysis_name(analysis_name)
  emit_section_header(gsub("_", " ", analysis_name), level = 4)
  emit_image(file.path(
    cfg$dir_graphs_png, safe_name,
    paste0(cfg$date, "_", analysis_name, "_PCA.png")
  ))
}

emit_section_header("Sample Distance Heatmaps", level = 3)
for (analysis_name in names(all_dds_objects)) {
  safe_name <- sanitize_analysis_name(analysis_name)
  emit_section_header(gsub("_", " ", analysis_name), level = 4)
  emit_image(file.path(
    cfg$dir_graphs_png, safe_name,
    paste0(cfg$date, "_", analysis_name, "_Heatmap.png")
  ))
}
```

## 3.3 Gene of Interest Expression
```{r goi-plots, results='asis'}
if (!is.null(cfg$qc_plot_settings$project_genes) &&
  length(cfg$qc_plot_settings$project_genes) > 0) {
  for (analysis_name in names(all_dds_objects)) {
    safe_name <- sanitize_analysis_name(analysis_name)
    emit_section_header(paste("GOI:", gsub("_", " ", analysis_name)), level = 4)

    paths <- vapply(
      cfg$qc_plot_settings$project_genes,
      function(g) {
        file.path(
          cfg$dir_graphs_png, safe_name,
          paste0(cfg$date, "_", analysis_name, "_GenePlot_", g, ".png")
        )
      },
      character(1)
    )

    existing <- paths[file.exists(paths)]
    if (length(existing) == 0) {
      cat("*No GOI plots generated for this analysis.*\n")
    } else {
      for (p in existing) emit_image(p)
    }
  }
} else {
  cat("*No project genes configured in cfg$qc_plot_settings$project_genes.*\n")
}
```

## 3.4 Differential Expression Summary
```{r results-summary-table}
summary_list <- lapply(names(all_results_lists), function(analysis_name) {
  analysis_results <- all_results_lists[[analysis_name]]
  if (!length(analysis_results)) {
    return(NULL)
  }

  lapply(names(analysis_results), function(comp_name) {
    res_df <- analysis_results[[comp_name]]
    sig_df <- dplyr::filter(
      res_df,
      !is.na(padj),
      padj < cfg$qval_threshold,
      abs(log2FoldChange) > cfg$lfc_threshold
    )
    data.frame(
      Comparison = comp_name,
      Total.Genes = nrow(res_df),
      DEGs = nrow(sig_df),
      Up = sum(sig_df$log2FoldChange > 0),
      Down = sum(sig_df$log2FoldChange < 0),
      stringsAsFactors = FALSE,
      check.names = FALSE
    )
  })
})

summary_df <- dplyr::bind_rows(unlist(summary_list, recursive = FALSE))
if (nrow(summary_df)) {
  reactable::reactable(
    summary_df,
    searchable = TRUE,
    bordered = TRUE,
    highlight = TRUE,
    columns = list(Comparison = colDef(minWidth = 380))
  )
} else {
  cat("*No valid comparisons were found to summarize.*\n")
}
```

## 3.5 Detailed Comparison Results

This section provides detailed results for each comparison, including interactive tables of DEGs and various plots.

```{r dynamic-results-report, results='asis'}
for (analysis_name in names(all_results_lists)) {
  safe_analysis_name <- sanitize_analysis_name(analysis_name)
  emit_section_header(paste("DEG Results for", gsub("_", " ", analysis_name)), level = 3)

  analysis_results <- all_results_lists[[analysis_name]]
  if (length(analysis_results) == 0) next

  for (comp_name in names(analysis_results)) {
    emit_section_header(gsub("_", " ", comp_name), level = 4)

    res_df <- analysis_results[[comp_name]]
    sig_genes <- res_df %>%
      dplyr::filter(
        !is.na(padj),
        padj < cfg$qval_threshold,
        abs(log2FoldChange) > cfg$lfc_threshold
      )

    # Use helper
    emit_sig_gene_table(sig_genes, cfg)

    png_dir <- file.path(cfg$dir_graphs_png, safe_analysis_name)
    emit_standard_comp_plots(comp_name, png_dir, cfg$date)

    if (length(gene_sets) > 0) {
      for (gs_name in names(gene_sets)) {
        emit_gene_set_heatmap(comp_name, gs_name, png_dir, cfg$date)
        emit_gene_set_boxplots(comp_name, gs_name, png_dir, cfg$date)
      }
    }
  }
}
```

---

# 4. Session

This section provides information about the R session, including the versions of all loaded packages, to ensure reproducibility.

```{r session-info}
sessionInfo()
```
